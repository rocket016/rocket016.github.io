[{"id":"5a4916485d9685034cdde3acb00444a2","title":"科技节智能车小记","content":"比赛要求本次科技节比赛要求通过遥控和电磁的方式，让小车绕着赛道跑一圈，时间最短者获胜\n\n遥控器和小车必须用单片机控制\nPCB必须自制或者用洞洞板\n\n赛道如下：\n\n\n\n\n\n\n\n\n\n\n（并没有三叉路口，对新生十分友好）\n设计思路总体思路开发板为了在短时间内快速完成开发，采用了arduino开发板\n谁能拒绝一块粉色的开发板呢\n车模车模方面，一开始使用最便宜的4个电机的小车，但发现效果太垃圾了\n首先，电机也没有编码器，无法准确控制车轮的转速\n其次，转速根本不够快，很难在内卷的时代获胜\n可能是学长看到我的车模太垃圾了，友情提供了一个车模，技术参数如下：\n\n采用520电机驱动，最高支持电压12V\n自带霍尔编码器，精度为330脉冲/转\n\n图片如下：\n\n电机驱动考虑到电流不会特别大，于是采用了性价比最高的DRV8833驱动板\n\n支持pwm控制，可以调速\n最大10.8V电压和1.5A电流 (比赛的时候直接上12V了，也没炸)\n\n遥控车思路首先，需要有一个遥控器结合玩遥控车的经验，采用arduino+摇杆电位计的方式\n最初的设计图如下：\n\n摇杆返回模拟值电压，通过arduino自带的ADC，转成0-1024的整型值\nint x1 = analogRead(A1);//left\nint x2 = analogRead(A2);//right\n\n接着，要进行通信通信方面，采用HC-12 wifi无线串口模块，默认波特率9600\n发送的时候，将左右摇杆的数值组合为字符串，并且使用分隔符，确保接受端能正常接收。\nHC.print(&#39;L&#39;);\nHC.print(leftsig);&#x2F;&#x2F;符号\nHC.print(sendleft);&#x2F;&#x2F;数值\nHC.print(&#39;R&#39;);&#x2F;&#x2F;分隔符\nHC.print(rightsig);&#x2F;&#x2F;符号\nHC.print(sendright);&#x2F;&#x2F;数值\nHC.print(&#39;x&#39;);\nHC.print(&#39;z&#39;);\n\n接收的时候，由于长度不固定，需要全部读入，arduino里面有一个readStringUntil函数，十分滴好用。我发送的时候采用z结尾，所以可以完整的读到全部数据。\n然后，对接收到的数据进行分割，按照位转化成整型数，代码如下 （点击可展开）\n\nDetails\n&#x2F;&#x2F;接收的数据 L+100R+100xz\nj&#x3D;0;\nrec&#x3D;HC.readStringUntil(&#39;z&#39;);\nlen&#x3D;rec.length();\nwhile(i&lt;len&amp;&amp;rec[i]!&#x3D;&#39;R&#39;)\n&#123;\n    i++;\n&#125;\nswitch(i)\n&#123;\n    case 5:&#x2F;&#x2F;表示有5位（L+100）的情况，直接为100\n    &#123;\n        if(rec[1]&#x3D;&#x3D;&#39;+&#39;)\n            left&#x3D;100;\n        else\n        \tleft&#x3D;-100;\n        break;\n    &#125;\n    case 4:&#x2F;&#x2F;4位（数字两位），依次转化\n    &#123;\n        if(rec[1]&#x3D;&#x3D;&#39;+&#39;)\n        \tleft&#x3D;10*(rec[2]-&#39;0&#39;)+rec[3]-&#39;0&#39;;\n        else\n        \tleft&#x3D;-(10*(rec[2]-&#39;0&#39;)+rec[3]-&#39;0&#39;);\n        break;\n    &#125;\n    case 3:&#x2F;&#x2F;3位（数字只有一位）\n    &#123;\n        if(rec[1]&#x3D;&#x3D;&#39;+&#39;)\n        \tleft&#x3D;rec[2]-&#39;0&#39;;\n        else\n        \tleft&#x3D;-(rec[2]-&#39;0&#39;);\n        break;\n    &#125;\n    default:\n    \tleft&#x3D;0;\n&#125;\n\n\n\n\n\n再者，要让车跑起来首先，要接收编码器的数据。\n霍尔编码器，每转过一定角度就会产生一次脉冲，因此，可以使用io口中断的方式，每收到一次脉冲，计数器+1，只要计数周期恒定，计数的多少就反映了当前的转速。\n还要判断正反转，传感器有AB相位，A为高，B为低时正转，反则为反转\n下图为正转的时候ab相位的输出波形图：\n\n判断代码如下：\nattachInterrupt(digitalPinToInterrupt(2), left, RISING);&#x2F;&#x2F;启用2口中断\nvoid left()\n&#123;\n  if(digitalRead(10)&#x3D;&#x3D;1)\n  \tleftcount++;\n  else\n  \tleftcount--;\n&#125;\n\n这样即可获得转速，每次循环结束读取数值之后，将数值清零就行了\n接着，采用pid算法，对电机进行控制\n我这里只用了p和d控制，已经获得了不错的效果，对于突然变化的负载的反应速度还算可以。\n\n\n\n\n\n\n\nWARNING\n提示：控制电机的转速需要用到增量式pid算法，而不是位置式\n\n\n\n\n\n\n\n\n\n\n关于pid算法的原理和两种pid的区别，我（可能）会再写一篇文章来解释\n然后，将pid计算之后的转速信号转化为pwm，输入到电机驱动板之中，就可以控制小车的转速了。\n至此，遥控车的制作完成，剩下的就是练操作以及熟悉赛道了\n电磁车思路电磁车和寻迹小车差不多，只不过，电磁电磁车巡的是电磁赛道。\n赛道中央会有一条电线，其中通有20kHz，100mA的正弦交流电。\n根据高中知识，交流电会在电线附近激发交变磁场\n通过电磁传感器搭载的电感，可以感知磁场，从而感知车辆偏离中心线的程度。\n\n输出的是四个电感感应到的数值，实测数值在100-500之间\n进行归一化处理，限制幅度，方便计算误差 (其实就是把得到的数值都除以一个常数)\n接着，进行p计算，将两边电感的差值乘以一个系数，加到左右车轮的转速上，实现控制小车的转向\n经过一番调参，最终实现小车的寻迹\n核心代码如下：\n&#x2F;&#x2F;读取电感\nfloat x1 &#x3D; analogRead(A0)&#x2F;3.0;\nfloat x2 &#x3D; analogRead(A1)&#x2F;3.0;\nfloat x3 &#x3D; analogRead(A2)&#x2F;3.0;\nfloat x4 &#x3D; analogRead(A3)&#x2F;3.0;\nfloat err2&#x3D;(x1+x2)&#x2F;2-(x3+x4)&#x2F;2;&#x2F;&#x2F;取平均值，最终的误差\nfloat basespeed&#x3D;90;&#x2F;&#x2F;基础转速\n&#x2F;&#x2F;计算两轮转速\nleftpid(basespeed-err3*p);&#x2F;&#x2F;差速转向\nrightpid(basespeed+err3*p);\n\n比赛结果首先，感谢大二学长的不杀之恩，毕竟他们的车模和代码是去打国赛的啊…\n最后，在12.6V电压的“超频”下，本车包揽两个组别的第一，成绩如下\n\n遥控组18.8s\n电磁组19.8s\n获得共计1200元奖金  (虽然下学期才到账)\n\n\n\n\n\n\n\n\n\n\n\n\n最后，本项目所有代码如下，欢迎交流\n抄也没用，比赛已经打完了了\n开源环节遥控组发送（遥控器代码）\nDetails\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial HC(3,2);&#x2F;&#x2F;RX&#x3D;3,TX&#x3D;2\nvoid setup() &#123;\n  &#x2F;&#x2F; put your setup code here, to run once:\n Serial.begin(9600);\n HC.begin(9600);\n pinMode(4, OUTPUT); \n pinMode(5, OUTPUT); \n pinMode(6, OUTPUT); \n pinMode(7, OUTPUT); \n pinMode(8, OUTPUT); \n pinMode(9, OUTPUT); \n pinMode(10, OUTPUT); \n pinMode(11, OUTPUT); \n pinMode(12, OUTPUT); \n pinMode(A1, INPUT);\n pinMode(A2, INPUT);\n for(int i&#x3D;4;i&lt;&#x3D;13;i++)\n &#123;\n    digitalWrite(i,0);\n &#125;\n digitalWrite(4,1);\n digitalWrite(9,1);\n for(int i&#x3D;0;i&lt;4;i++)\n &#123;\n    digitalWrite(i+4,0);\n    digitalWrite(i+9,0);\n    digitalWrite(i+5,1);\n    digitalWrite(i+10,1);\n    delay(100);\n &#125;\n for(int i&#x3D;4;i&lt;&#x3D;13;i++)\n &#123;\n    digitalWrite(i,0);\n &#125;\n digitalWrite(11,1);\n&#125;\nfloat left;\nfloat right;\nint sendleft&#x3D;0;\nint sendright&#x3D;0;\nchar charleft;\nchar leftsig;\nchar rightsig;\nchar charright;\nint gcount&#x3D;0;&#x2F;&#x2F;             \nint light[14]&#x3D;&#123;0&#125;;&#x2F;&#x2F;分别代表 \nvoid loop() \n&#123;\n  &#x2F;&#x2F; put your main code here, to run repeatedly:\n  \n  delayMicroseconds(100);&#x2F;&#x2F;主延时\n  gcount++;\n  if(gcount&#x3D;&#x3D;200)\n  &#123;\n    gcount&#x3D;0;\n  int x1 &#x3D; analogRead(A1);&#x2F;&#x2F;left\n  int x2 &#x3D; analogRead(A2);&#x2F;&#x2F;right\n  &#x2F;&#x2F;Serial.println(x1);\n  &#x2F;&#x2F;left判定\n  \n  if(abs(x1-541)&gt;&#x3D;3)\n  &#123;\n    if(x1-514&gt;0)\n      left&#x3D;(x1-514)&#x2F;509.0;\n    else\n      left&#x3D;(x1-514)&#x2F;514.0;\n  &#125;\n  else\n  &#123;\n    left&#x3D;0;\n  &#125;\n  if(left&gt;100)\n  &#123;\n    left&#x3D;100;\n  &#125;\n  if(left&lt;-100)\n  &#123;\n    left&#x3D;-100;\n  &#125;\n\n  \n  if(abs(x2-533)&gt;&#x3D;5)\n  &#123;\n    if(x2-533&gt;0)\n      right&#x3D;(x2-533)&#x2F;490.0;\n\n    else\n      right&#x3D;(x2-533)&#x2F;533.0;\n  &#125;\n  else\n  &#123;\n    right&#x3D;0;\n  &#125;\n  \n  if(right&gt;100)\n  &#123;\n    right&#x3D;100.0;\n  &#125;\n  if(right&lt;-100)\n  &#123;\n    right&#x3D;-100.0;\n  &#125;\n  \n  sendleft&#x3D;left*100;\n  sendright&#x3D;right*100;\n\n  &#x2F;&#x2F;led灯效 --------------------------------------led part-------------------------------\n\n  if(sendleft&lt;&#x3D;0)\n  &#123;\n    for(int i&#x3D;4;i&lt;&#x3D;8;i++)\n      light[i]&#x3D;0;\n  &#125;\n  else\n  if(sendleft&gt;0&amp;&amp;sendleft&lt;&#x3D;20)\n  &#123;\n    light[8]&#x3D;1;\n    for(int i&#x3D;4;i&lt;&#x3D;7;i++)\n      light[i]&#x3D;0;\n  &#125;\n  else\n  if(sendleft&gt;20&amp;&amp;sendleft&lt;&#x3D;40)\n  &#123;\n    light[8]&#x3D;1;\n    light[7]&#x3D;1;\n    light[6]&#x3D;0;\n    light[5]&#x3D;0;\n    light[4]&#x3D;0;\n  &#125;\n  else\n  if(sendleft&gt;40&amp;&amp;sendleft&lt;&#x3D;60)\n  &#123;\n    light[8]&#x3D;1;\n    light[7]&#x3D;1;\n    light[6]&#x3D;1;\n    light[5]&#x3D;0;\n    light[4]&#x3D;0;\n  &#125;\n  else\n  if(sendleft&gt;60&amp;&amp;sendleft&lt;&#x3D;80)\n  &#123;\n    light[8]&#x3D;1;\n    light[7]&#x3D;1;\n    light[6]&#x3D;1;\n    light[5]&#x3D;1;\n    light[4]&#x3D;0;\n  &#125;\n  else\n  &#123;\n    light[8]&#x3D;1;\n    light[7]&#x3D;1;\n    light[6]&#x3D;1;\n    light[5]&#x3D;1;\n    light[4]&#x3D;1;\n  &#125;\n&#x2F;&#x2F; left led--------------------------------------------left led end-----------------------------\n  if(sendright&gt;80)\n  &#123;\n    light[9]&#x3D;0;\n    light[10]&#x3D;0;\n    light[11]&#x3D;1;\n    light[12]&#x3D;1;\n    light[13]&#x3D;1;\n  &#125;\n  else\n  if(sendright&lt;80&amp;&amp;sendright&gt;&#x3D;40)\n  &#123;\n    light[9]&#x3D;0;\n    light[10]&#x3D;0;\n    light[11]&#x3D;1;\n    light[12]&#x3D;1;\n    light[13]&#x3D;0;\n  &#125;\n  else\n  if(abs(sendright)&lt;40)\n  &#123;\n    light[9]&#x3D;0;\n    light[10]&#x3D;0;\n    light[11]&#x3D;1;\n    light[12]&#x3D;0;\n    light[13]&#x3D;0;\n  &#125;\n  else\n  if(sendright&lt;&#x3D;-40&amp;&amp;sendright&gt;&#x3D;-80)\n  &#123;\n    light[9]&#x3D;0;\n    light[10]&#x3D;1;\n    light[11]&#x3D;1;\n    light[12]&#x3D;0;\n    light[13]&#x3D;0;\n  &#125;\n  else\n  &#123;\n    light[9]&#x3D;1;\n    light[10]&#x3D;1;\n    light[11]&#x3D;1;\n    light[12]&#x3D;0;\n    light[13]&#x3D;0;\n  &#125;\n  \n  if(sendleft&gt;&#x3D;0) leftsig&#x3D;&#39;+&#39;;\n  else leftsig&#x3D;&#39;-&#39;;\n\n  if(sendright&gt;&#x3D;0) rightsig&#x3D;&#39;+&#39;;\n  else rightsig&#x3D;&#39;-&#39;;\n  &#x2F;&#x2F;符号处理\n\n  sendleft&#x3D;abs(sendleft);\n  sendright&#x3D;abs(sendright);\n\n  &#x2F;&#x2F;转字符发送\n&#x2F;&#x2F;  Serial.print(sendleft);\n&#x2F;&#x2F;  Serial.print(&quot;  &quot;);\n&#x2F;&#x2F;  Serial.println(sendright);\n&#x2F;&#x2F;  for(int i&#x3D;4;i&lt;&#x3D;13;i++)\n&#x2F;&#x2F;  &#123;\n&#x2F;&#x2F;    Serial.print(light[i]);\n&#x2F;&#x2F;    Serial.print(&quot;  &quot;);\n&#x2F;&#x2F;  &#125;\n&#x2F;&#x2F;  Serial.print(&quot;\\n&quot;);\n  HC.print(&#39;L&#39;);\n  HC.print(leftsig);\n  HC.print(sendleft);\n  HC.print(&#39;R&#39;);\n  HC.print(rightsig);\n  HC.print(sendright);\n  HC.print(&#39;x&#39;);\n  HC.print(&#39;z&#39;);\n  &#125;\n  &#x2F;&#x2F;----------------------------------------end of receive--------------------------------\n  &#x2F;&#x2F;HC.print(charright);\n  if(gcount%5&#x3D;&#x3D;0)\n  &#123;\n    digitalWrite(4,light[4]);\n    digitalWrite(5,light[5]);\n&#x2F;&#x2F;    digitalWrite(6,0);\n&#x2F;&#x2F;    digitalWrite(7,0);\n&#x2F;&#x2F;    digitalWrite(8,0);\n&#x2F;&#x2F;    digitalWrite(9,0);\n&#x2F;&#x2F;    digitalWrite(10,0);\n&#x2F;&#x2F;    digitalWrite(11,0);\n    digitalWrite(12,0);\n    digitalWrite(13,0);\n  &#125;\n  else\n  if(gcount%5&#x3D;&#x3D;1)\n  &#123;\n    digitalWrite(4,0);\n    digitalWrite(5,0);\n    digitalWrite(6,light[6]);\n    digitalWrite(7,light[7]);\n&#x2F;&#x2F;    digitalWrite(8,0);\n&#x2F;&#x2F;    digitalWrite(9,0);\n&#x2F;&#x2F;    digitalWrite(10,0);\n&#x2F;&#x2F;    digitalWrite(11,0);\n&#x2F;&#x2F;    digitalWrite(12,0);\n&#x2F;&#x2F;    digitalWrite(13,0); \n  &#125;\n  else\n  if(gcount%5&#x3D;&#x3D;2)\n  &#123;\n&#x2F;&#x2F;    digitalWrite(4,0);\n&#x2F;&#x2F;    digitalWrite(5,0);\n    digitalWrite(6,0);\n    digitalWrite(7,0);\n    digitalWrite(8,light[8]);\n    digitalWrite(9,light[9]);\n&#x2F;&#x2F;    digitalWrite(10,0);\n&#x2F;&#x2F;    digitalWrite(11,0);\n&#x2F;&#x2F;    digitalWrite(12,0);\n&#x2F;&#x2F;    digitalWrite(13,0); \n  &#125;\n  else\n  if(gcount%5&#x3D;&#x3D;3)\n  &#123;\n&#x2F;&#x2F;    digitalWrite(4,0);\n&#x2F;&#x2F;    digitalWrite(5,0);\n&#x2F;&#x2F;    digitalWrite(6,0);\n&#x2F;&#x2F;    digitalWrite(7,0);\n    digitalWrite(8,0);\n    digitalWrite(9,0);\n    digitalWrite(10,light[10]);\n    digitalWrite(11,light[11]);\n&#x2F;&#x2F;    digitalWrite(12,0);\n&#x2F;&#x2F;    digitalWrite(13,0); \n  &#125;\n  else\n  if(gcount%5&#x3D;&#x3D;4)\n  &#123;\n&#x2F;&#x2F;    digitalWrite(4,0);\n&#x2F;&#x2F;    digitalWrite(5,0);\n&#x2F;&#x2F;    digitalWrite(6,0);\n&#x2F;&#x2F;    digitalWrite(7,0);\n&#x2F;&#x2F;    digitalWrite(8,0);\n&#x2F;&#x2F;    digitalWrite(9,0);\n    digitalWrite(10,0);\n    digitalWrite(11,0);\n    digitalWrite(12,light[12]);\n    digitalWrite(13,light[13]); \n  &#125;\n\n   \n&#x2F;&#x2F;    Serial.print(&#39;L&#39;);\n&#x2F;&#x2F;  Serial.print(leftsig);\n&#x2F;&#x2F;  Serial.print(charleft);\n&#x2F;&#x2F;  Serial.print(&#39;R&#39;);\n&#x2F;&#x2F;  Serial.print(rightsig);\n&#x2F;&#x2F;  Serial.print(charright);\n&#125;\n\n\n\n遥控组接收 (车上的代码)\nDetails\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial HC(7,4);&#x2F;&#x2F;RX,TX\nvoid setup() &#123;\n  &#x2F;&#x2F; put your setup code here, to run once:\n  Serial.begin(9600);\n  HC.begin(9600);\n  attachInterrupt(digitalPinToInterrupt(2), left, RISING);&#x2F;&#x2F;2为左边中断口\n  attachInterrupt(digitalPinToInterrupt(3), right, RISING);&#x2F;&#x2F;3为右边中断口\n  pinMode(6, OUTPUT); &#x2F;&#x2F;in2\n  pinMode(5, OUTPUT); &#x2F;&#x2F;in1（left）\n  pinMode(10,INPUT);\n  pinMode(12,INPUT);\n  pinMode(11, OUTPUT); &#x2F;&#x2F;in2(right)\n  pinMode(9, OUTPUT); &#x2F;&#x2F;in1\n&#125;\nlong int leftcount&#x3D;0;\nlong int rightcount&#x3D;0;\nvoid left()\n&#123;\n  if(digitalRead(10)&#x3D;&#x3D;1)\n  leftcount++;\n  else\n  leftcount--;\n&#125;\nvoid right()\n&#123;\n  if(digitalRead(12)&#x3D;&#x3D;0)\n  rightcount++;\n  else\n  rightcount--;\n&#125;\n\nint leftlasterr&#x3D;0;&#x2F;&#x2F;左边lasterr\nint leftnowerr&#x3D;0;&#x2F;&#x2F;左边当前误差\nfloat leftout&#x3D;0;&#x2F;&#x2F;左边输出\nvoid leftpid(float lefttar)\n&#123;\n  leftnowerr&#x3D;lefttar-leftcount;\n  &#x2F;&#x2F;Serial.print(leftnowerr);\n  leftout+&#x3D;leftnowerr*1.5+(leftnowerr-leftlasterr)*7.5;\n  if(leftout&gt;255)\n    leftout&#x3D;255;\n  if(leftout&lt;-255)\n    leftout&#x3D;-255;\n  if(abs(leftnowerr)&lt;&#x3D;1&amp;&amp;abs(lefttar)&lt;&#x3D;1)\n  leftout&#x3D;0;\n&#125;\nint rightlasterr&#x3D;0;&#x2F;&#x2F;左边lasterr\nint rightnowerr&#x3D;0;&#x2F;&#x2F;左边当前误差\nfloat rightout&#x3D;0;&#x2F;&#x2F;左边输出\nvoid rightpid(float righttar)\n&#123;\n  rightnowerr&#x3D;righttar-rightcount;\n  rightout+&#x3D;rightnowerr*1.5+(rightnowerr-rightlasterr)*7.5;\n  if(rightout&gt;255)\n    rightout&#x3D;255;\n  if(rightout&lt;-255)\n    rightout&#x3D;-255;\n  if(abs(rightnowerr)&lt;1&amp;&amp;abs(righttar)&lt;1)\n  rightout&#x3D;0;\n&#125;\n\n\n\nString rec;\nvoid loop() &#123;\n  &#x2F;&#x2F; put your main code here, to run repeatedly:\n  \n  &#x2F;&#x2F;Serial.println(HC.available());\n  char re;\n  int left;\n  int right;\n  char leftsig;\n  char rightsig;\n  int i&#x3D;0;\n  int j&#x3D;0;\n  int len;\n  float leftmotor;\n  float rightmotor;\n  int left1,left2,left3,right1,right2,right3;\n  &#x2F;&#x2F;Serial.println(&quot;ok&quot;);\n  if(HC.available())\n  &#123;\n      i&#x3D;0;\n      j&#x3D;0;\n      rec&#x3D;HC.readStringUntil(&#39;z&#39;);\n      len&#x3D;rec.length();\n      &#x2F;&#x2F;Serial.println(rec);\n      while(i&lt;len&amp;&amp;rec[i]!&#x3D;&#39;R&#39;)\n      &#123;\n        i++;\n      &#125;\n      switch(i)\n      &#123;\n        case 5:\n          &#123;\n            if(rec[1]&#x3D;&#x3D;&#39;+&#39;)\n              left&#x3D;100;\n            else\n              left&#x3D;-100;\n            break;\n          &#125;\n        case 4:\n          &#123;\n            if(rec[1]&#x3D;&#x3D;&#39;+&#39;)\n            left&#x3D;10*(rec[2]-&#39;0&#39;)+rec[3]-&#39;0&#39;;\n            else\n            left&#x3D;-(10*(rec[2]-&#39;0&#39;)+rec[3]-&#39;0&#39;);\n            break;\n          &#125;\n         case 3:\n          &#123;\n            if(rec[1]&#x3D;&#x3D;&#39;+&#39;)\n            left&#x3D;rec[2]-&#39;0&#39;;\n            else\n            left&#x3D;-(rec[2]-&#39;0&#39;);\n            break;\n          &#125;\n         default:\n          left&#x3D;0;\n      &#125;\n      while(i+j&lt;len&amp;&amp;rec[i+j]!&#x3D;&#39;x&#39;)\n      &#123;\n        j++;\n      &#125;\n      switch(j)\n      &#123;\n        case 5:\n          &#123;\n            if(rec[i+1]&#x3D;&#x3D;&#39;+&#39;)\n              right&#x3D;100;\n            else\n              right&#x3D;-100;\n            break;\n          &#125;\n        case 4:\n          &#123;\n            if(rec[i+1]&#x3D;&#x3D;&#39;+&#39;)\n            right&#x3D;10*(rec[i+2]-&#39;0&#39;)+rec[i+3]-&#39;0&#39;;\n            else\n            right&#x3D;-(10*(rec[i+2]-&#39;0&#39;)+rec[i+3]-&#39;0&#39;);\n            break;\n          &#125;\n         case 3:\n          &#123;\n            if(rec[i+1]&#x3D;&#x3D;&#39;+&#39;)\n            right&#x3D;rec[i+2]-&#39;0&#39;;\n            else\n            right&#x3D;-(rec[i+2]-&#39;0&#39;);\n            break;\n          &#125;\n         default:\n          right&#x3D;0;\n      &#125;\n      \n  &#125;&#x2F;&#x2F;读取遥控器数值end\n      &#x2F;&#x2F;left*&#x3D;0.5;\n&#x2F;&#x2F;可用\n      if(abs(left)&gt;&#x3D;10)\n      &#123;\n        leftmotor&#x3D;left*(100+right)&#x2F;100.0;\n        rightmotor&#x3D;left*(100-right)&#x2F;100.0;\n      &#125;\n      else\n      &#123;\n        leftmotor&#x3D;left+right*0.09;\n        rightmotor&#x3D;left-right*0.09;\n      &#125;\n&#x2F;&#x2F;可用勿删 \n      float t&#x3D;abs(left);\n      if(t&lt;&#x3D;10)\n      &#123;\n        leftmotor&#x3D;left+right*0.09;\n        rightmotor&#x3D;left-right*0.09;\n      &#125;\n      if(t&gt;10&amp;&amp;t&lt;&#x3D;20)\n      &#123;\n        leftmotor&#x3D;left+right*0.13;\n        rightmotor&#x3D;left-right*0.13;  \n      &#125;\n      if(t&gt;20&amp;&amp;t&lt;&#x3D;30)\n      &#123;\n        leftmotor&#x3D;left+right*0.17;\n        rightmotor&#x3D;left-right*0.17;  \n      &#125;\n      if(t&gt;30&amp;&amp;t&lt;&#x3D;40)\n      &#123;\n        leftmotor&#x3D;left+right*0.5;\n        rightmotor&#x3D;left-right*0.5;  \n      &#125;\n      if(t&gt;40)\n      &#123;\n        leftmotor&#x3D;left+right*1;\n        rightmotor&#x3D;left-right*1; \n      &#125;\n      \n      \n      \n      &#x2F;&#x2F;计算速度\n      \n      if(leftmotor&gt;100)\n      &#123;\n        leftmotor&#x3D;100;\n      &#125;\n      if(leftmotor&lt;-100)\n      &#123;\n        leftmotor&#x3D;-100;\n      &#125;\n      if(rightmotor&gt;100)\n      &#123;\n        rightmotor&#x3D;100;\n      &#125;\n      if(rightmotor&lt;-100)\n      &#123;\n        rightmotor&#x3D;-100;\n      &#125;\n      &#x2F;&#x2F;解算速度\n      &#x2F;&#x2F;右边电机驱动\n      leftpid((int)leftmotor);&#x2F;&#x2F;-------------------pid计算\n      rightpid((int)rightmotor);\n&#x2F;&#x2F;      Serial.print(left);&#x2F;&#x2F;期望转速\n&#x2F;&#x2F;      Serial.print(&quot; &quot;);\n&#x2F;&#x2F;      Serial.print(right);&#x2F;&#x2F;期望转速\n&#x2F;&#x2F;      Serial.println(&quot; &quot;);\n      \n      Serial.print(leftmotor*0.4);&#x2F;&#x2F;期望转速\n      Serial.print(&quot; &quot;);\n      Serial.print(leftcount);&#x2F;&#x2F;实际转速\n      Serial.print(&quot; &quot;);\n      Serial.print(&quot; &quot;);\n      Serial.print(leftout);&#x2F;&#x2F;输出\n      Serial.print(rightmotor*0.4);&#x2F;&#x2F;期望转速\n      Serial.print(&quot; &quot;);\n      Serial.print(rightcount);&#x2F;&#x2F;实际转速\n      Serial.print(&quot; &quot;);\n      Serial.println(rightout);&#x2F;&#x2F;输出\n      if(rightout&gt;0)\n      &#123;\n        digitalWrite(11, LOW);\n        analogWrite(9, (int)rightout);\n      &#125;\n      if(rightout&lt;0)\n      &#123;\n        digitalWrite(9, LOW);\n        analogWrite(11, (int)abs(rightout));\n      &#125;\n      if(rightout&#x3D;&#x3D;0)\n      &#123;\n        digitalWrite(11, LOW);\n        digitalWrite(9, LOW);\n      &#125;\n      &#x2F;&#x2F;左边电机驱动\n      if(leftout&gt;0)\n      &#123;\n        digitalWrite(5, LOW);\n        analogWrite(6, (int)leftout);\n      &#125;\n      if(leftout&lt;0)\n      &#123;\n        digitalWrite(6, LOW);\n        analogWrite(5, (int)abs(leftout));\n      &#125;\n      if(leftout&#x3D;&#x3D;0)\n      &#123;\n        digitalWrite(5, LOW);\n        digitalWrite(6, LOW);\n      &#125;\n  &#x2F;&#x2F;更新数据，清除编码器\n  leftlasterr&#x3D;leftnowerr;\n  rightlasterr&#x3D;rightnowerr;\n  leftcount&#x3D;0;\n  rightcount&#x3D;0;\n  delay(25);\n&#125;\n\n\n\n电磁组\nDetails\nvoid setup() &#123;\n  &#x2F;&#x2F; put your setup code here, to run once:\n  Serial.begin(9600);\n  attachInterrupt(digitalPinToInterrupt(2), left, RISING);&#x2F;&#x2F;2为左边中断口\n  attachInterrupt(digitalPinToInterrupt(3), right, RISING);&#x2F;&#x2F;3为右边中断口\n  pinMode(6, OUTPUT); &#x2F;&#x2F;in2\n  pinMode(5, OUTPUT); &#x2F;&#x2F;in1（left）\n  pinMode(10,INPUT);\n  pinMode(12,INPUT);\n  pinMode(11, OUTPUT); &#x2F;&#x2F;in2(right)\n  pinMode(9, OUTPUT); &#x2F;&#x2F;in1\n&#125;\nlong int leftcount&#x3D;0;\nlong int rightcount&#x3D;0;\nvoid left()\n&#123;\n  if(digitalRead(10)&#x3D;&#x3D;1)\n  leftcount++;\n  else\n  leftcount--;\n&#125;\nvoid right()\n&#123;\n  if(digitalRead(12)&#x3D;&#x3D;0)\n  rightcount++;\n  else\n  rightcount--;\n&#125;\n\nfloat leftlasterr&#x3D;0;&#x2F;&#x2F;左边lasterr\nfloat leftnowerr&#x3D;0;&#x2F;&#x2F;左边当前误差\nfloat leftout&#x3D;0;&#x2F;&#x2F;左边输出\nint leftpid(float lefttar)\n&#123;\n  leftnowerr&#x3D;lefttar-leftcount;\n  leftout+&#x3D;leftnowerr*2+(leftnowerr-leftlasterr)*8;\n  if(leftout&gt;255)\n    leftout&#x3D;255;\n  if(leftout&lt;-255)\n    leftout&#x3D;-255;\n  if(abs(leftnowerr)&lt;1&amp;&amp;abs(lefttar)&lt;1)\n  leftout&#x3D;0;\n&#125;\nfloat rightlasterr&#x3D;0;&#x2F;&#x2F;左边lasterr\nfloat rightnowerr&#x3D;0;&#x2F;&#x2F;左边当前误差\nfloat rightout&#x3D;0;&#x2F;&#x2F;左边输出\nint rightpid(float righttar)\n&#123;\n  rightnowerr&#x3D;righttar-rightcount;\n  rightout+&#x3D;rightnowerr*2+(rightnowerr-rightlasterr)*8;\n  if(rightout&gt;255)\n    rightout&#x3D;255;\n  if(rightout&lt;-255)\n    rightout&#x3D;-255;\n  if(abs(rightnowerr)&lt;1&amp;&amp;abs(righttar)&lt;1)\n  rightout&#x3D;0;\n&#125;\n\n\nfloat leftmotor&#x3D;20;\nfloat rightmotor&#x3D;20;\nint basespeed&#x3D;100;&#x2F;&#x2F;100 30s\nfloat p&#x3D;0.6;\nvoid loop() &#123;\n  &#x2F;&#x2F; put your main code here, to run repeatedly:\n  delay(50);\n  float x1 &#x3D; analogRead(A0)&#x2F;3.0;&#x2F;&#x2F;left\n  float x2 &#x3D; analogRead(A1)&#x2F;3.0;&#x2F;&#x2F;right\n  float x3 &#x3D; analogRead(A2)&#x2F;3.0;&#x2F;&#x2F;right\n  float x4 &#x3D; analogRead(A3)&#x2F;3.0;&#x2F;&#x2F;right\n\n  int last_x1&#x3D;x1;\n  int last_x2&#x3D;x2;\n  int last_x3&#x3D;x3;\n  int last_x4&#x3D;x4;\n  float err&#x3D;x2-x3;&#x2F;&#x2F;正的偏差左转，负的右转\n  float err1&#x3D;x1-x4;\n  float err2&#x3D;(x1+x2)&#x2F;2-(x3+x4)&#x2F;2;\n  float err3&#x3D;(err+err1)&#x2F;2;\n  \n&#x2F;&#x2F;  Serial.print(x1);\n&#x2F;&#x2F;  Serial.print(&#39; &#39;);\n&#x2F;&#x2F;  Serial.print(x2);\n&#x2F;&#x2F;  Serial.print(&#39; &#39;);\n&#x2F;&#x2F;  Serial.print(x3);\n&#x2F;&#x2F;  Serial.print(&#39; &#39;);\n&#x2F;&#x2F;  Serial.print(x4);\n&#x2F;&#x2F;  Serial.print(&#39; &#39;);\n  Serial.print(err3);\n  Serial.print(&#39; &#39;);\n  Serial.print(basespeed-err3*p);\n  Serial.print(&#39; &#39;);\n  Serial.print(basespeed+err3*p);\n  Serial.print(&#39; &#39;);\n  Serial.print(leftcount);\n  Serial.print(&#39; &#39;);\n  Serial.println(rightcount);\n  \n&#x2F;&#x2F;      Serial.print(leftmotor);&#x2F;&#x2F;期望转速\n&#x2F;&#x2F;      Serial.print(&quot; &quot;);\n&#x2F;&#x2F;      Serial.print(leftcount);&#x2F;&#x2F;实际转速\n&#x2F;&#x2F;      Serial.print(&quot; &quot;);\n&#x2F;&#x2F;      Serial.print(&quot; &quot;);\n&#x2F;&#x2F;      Serial.print(leftout);&#x2F;&#x2F;输出\n&#x2F;&#x2F;      Serial.print(rightmotor);&#x2F;&#x2F;期望转速\n&#x2F;&#x2F;      Serial.print(&quot; &quot;);\n&#x2F;&#x2F;      Serial.print(rightcount);&#x2F;&#x2F;实际转速\n&#x2F;&#x2F;      Serial.print(&quot; &quot;);\n&#x2F;&#x2F;      Serial.println(rightout);&#x2F;&#x2F;输出\n  \n  leftpid(basespeed-err3*p);&#x2F;&#x2F;-------------------pid计算\n  rightpid(basespeed+err3*p);\n  &#x2F;&#x2F;Serial.println(leftout);\n  if(rightout&gt;0)\n      &#123;\n        digitalWrite(11, LOW);\n        analogWrite(9, (int)rightout);\n      &#125;\n      if(rightout&lt;0)\n      &#123;\n        digitalWrite(9, LOW);\n        analogWrite(11, (int)abs(rightout));\n      &#125;\n      if(rightout&#x3D;&#x3D;0)\n      &#123;\n        digitalWrite(11, LOW);\n        digitalWrite(9, LOW);\n      &#125;\n      &#x2F;&#x2F;左边电机驱动\n      if(leftout&gt;0)\n      &#123;\n        digitalWrite(5, LOW);\n        analogWrite(6, (int)leftout);\n      &#125;\n      if(leftout&lt;0)\n      &#123;\n        digitalWrite(6, LOW);\n        analogWrite(5, (int)abs(leftout));\n      &#125;\n      if(leftout&#x3D;&#x3D;0)\n      &#123;\n        digitalWrite(5, LOW);\n        digitalWrite(6, LOW);\n      &#125;\n  &#x2F;&#x2F;更新数据，清除编码器\n  leftlasterr&#x3D;leftnowerr;\n  rightlasterr&#x3D;rightnowerr;\n  leftcount&#x3D;0;\n  rightcount&#x3D;0;\n&#125;\n\n\n\n\n\n\n\n\n\nTIP\n感谢观看~ \n\n\nby rocket 202211.21 23:14\n","slug":"科技节智能车小记","date":"2022-11-17T09:04:00.000Z","categories_index":"开发记录","tags_index":"嵌入式开发","author_index":"rock3t"},{"id":"86d9c5a53426ca98883f6e82dccc2ea1","title":"Welcome~","content":"欢迎来到rock3t的博客﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌\n点击上方链接进入阅读指南​‍﻿‌​‍﻿‌​‍﻿‌﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍﻿‌​‍\n阅读指南\n快速查看文章分类，请点击上方tag  \n按时间查看文章，请点击上方achieves \n想了解我，请点击About\n\n本人较忙，不定时更新博客，如果较长时间未更新请不要惊慌\n\n\n\n\n\n\nTIP\n转载本博客文章请表明出处哦\n\n","slug":"hello-world","date":"2022-11-01T10:41:00.000Z","categories_index":"","tags_index":"","author_index":"rock3t"}]